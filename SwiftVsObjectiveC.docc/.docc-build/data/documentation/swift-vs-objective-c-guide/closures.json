{"kind":"article","metadata":{"title":"Closures","roleHeading":"Article","role":"article"},"hierarchy":{"paths":[["doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide"]]},"abstract":[{"text":"Comparing closures in Swift with blocks in Objective-C.","type":"text"}],"primaryContentSections":[{"content":[{"text":"Overview","anchor":"Overview","level":2,"type":"heading"},{"inlineContent":[{"text":"Both Swift and Objective-C support closures (called “blocks” in Objective-C) for functional programming patterns. Swift provides cleaner syntax, better type inference, and more powerful capture semantics.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Basic-Syntax","text":"Basic Syntax","type":"heading"},{"level":3,"anchor":"Swift-Clean-Closure-Syntax","text":"Swift: Clean Closure Syntax","type":"heading"},{"code":["\/\/ Simple closure","let greeting = { (name: String) -> String in","    return \"Hello, \\(name)!\"","}","","print(greeting(\"Alice\"))  \/\/ Hello, Alice!","","\/\/ Closure with type inference","let numbers = [1, 2, 3, 4, 5]","let doubled = numbers.map { number in","    return number * 2","}","","\/\/ Even shorter with shorthand argument names","let tripled = numbers.map { $0 * 3 }","","\/\/ Trailing closure syntax","let filtered = numbers.filter { $0 > 2 }","print(filtered)  \/\/ [3, 4, 5]"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Objective-C-Block-Syntax","text":"Objective-C: Block Syntax","type":"heading"},{"code":["\/\/ Block type definition","NSString *(^greeting)(NSString *) = ^NSString *(NSString *name) {","    return [NSString stringWithFormat:@\"Hello, %@!\", name];","};","","NSLog(@\"%@\", greeting(@\"Alice\"));  \/\/ Hello, Alice!","","\/\/ Using blocks with NSArray","NSArray<NSNumber *> *numbers = @[@1, @2, @3, @4, @5];","","NSArray<NSNumber *> *doubled = [numbers objectsAtIndexes:[numbers indexesOfObjectsPassingTest:^BOOL(NSNumber *number, NSUInteger idx, BOOL *stop) {","    \/\/ More complex syntax required","    return [number integerValue] > 2;","}]];","","\/\/ Enumeration with blocks","[numbers enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) {","    NSLog(@\"Number at index %lu: %@\", (unsigned long)idx, number);","}];"],"type":"codeListing","syntax":"objective-c"},{"level":2,"anchor":"Function-Parameters","text":"Function Parameters","type":"heading"},{"level":3,"anchor":"Swift-Flexible-Closure-Parameters","text":"Swift: Flexible Closure Parameters","type":"heading"},{"code":["\/\/ Function taking closure as parameter","func processArray<T, U>(_ array: [T], transform: (T) -> U) -> [U] {","    return array.map(transform)","}","","\/\/ Multiple ways to call","let strings = [\"1\", \"2\", \"3\", \"4\", \"5\"]","","\/\/ Explicit closure syntax","let integers1 = processArray(strings, transform: { (str: String) -> Int in","    return Int(str) ?? 0","})","","\/\/ Type inference","let integers2 = processArray(strings) { str in","    Int(str) ?? 0","}","","\/\/ Shorthand arguments","let integers3 = processArray(strings) { Int($0) ?? 0 }","","\/\/ Trailing closure (when closure is last parameter)","let integers4 = processArray(strings) { Int($0) ?? 0 }","","print(integers4)  \/\/ [1, 2, 3, 4, 5]"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Objective-C-Block-Type-Definitions","text":"Objective-C: Block Type Definitions","type":"heading"},{"code":["\/\/ Block type definition","typedef NSNumber *(^TransformBlock)(NSString *input);","","\/\/ Function taking block as parameter","- (NSArray<NSNumber *> *)processArray:(NSArray<NSString *> *)array ","                            transform:(TransformBlock)transform {","    NSMutableArray<NSNumber *> *result = [NSMutableArray array];","    for (NSString *str in array) {","        NSNumber *transformed = transform(str);","        [result addObject:transformed];","    }","    return [result copy];","}","","\/\/ Usage (more verbose)","NSArray<NSString *> *strings = @[@\"1\", @\"2\", @\"3\", @\"4\", @\"5\"];","NSArray<NSNumber *> *integers = [self processArray:strings ","                                          transform:^NSNumber *(NSString *input) {","    return @([input integerValue]);","}];"],"type":"codeListing","syntax":"objective-c"},{"level":2,"anchor":"Capture-Semantics","text":"Capture Semantics","type":"heading"},{"level":3,"anchor":"Swift-Flexible-Capture-with-Safety","text":"Swift: Flexible Capture with Safety","type":"heading"},{"code":["func createCountingFunction() -> () -> Int {","    var counter = 0","    ","    \/\/ Closure captures 'counter' by reference","    return {","        counter += 1","        return counter","    }","}","","let count = createCountingFunction()","print(count())  \/\/ 1","print(count())  \/\/ 2","print(count())  \/\/ 3","","\/\/ Explicit capture list for memory safety","class ViewController {","    var name = \"ViewController\"","    ","    func setupTimer() {","        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] timer in","            guard let self = self else {","                timer.invalidate()","                return","            }","            print(\"Timer fired in \\(self.name)\")","        }","    }","    ","    func setupTimerWithUnowned() {","        \/\/ Use unowned when you know self won't be deallocated","        Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [unowned self] _ in","            print(\"Timer fired in \\(self.name)\")","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Objective-C-Manual-Memory-Management","text":"Objective-C: Manual Memory Management","type":"heading"},{"code":["\/\/ Capturing variables in blocks","typedef NSInteger (^CounterBlock)(void);","","- (CounterBlock)createCountingFunction {","    __block NSInteger counter = 0;  \/\/ __block allows modification","    ","    return ^NSInteger {","        counter++;","        return counter;","    };","}","","CounterBlock count = [self createCountingFunction];","NSLog(@\"%ld\", (long)count());  \/\/ 1","NSLog(@\"%ld\", (long)count());  \/\/ 2","","\/\/ Memory management with blocks","@interface ViewController : UIViewController","@property (nonatomic, strong) NSString *name;","- (void)setupTimer;","@end","","@implementation ViewController","","- (void)setupTimer {","    \/\/ Weak reference to prevent retain cycle","    __weak typeof(self) weakSelf = self;","    ","    [NSTimer scheduledTimerWithTimeInterval:1.0","                                    repeats:YES","                                      block:^(NSTimer *timer) {","        __strong typeof(weakSelf) strongSelf = weakSelf;","        if (strongSelf) {","            NSLog(@\"Timer fired in %@\", strongSelf.name);","        } else {","            [timer invalidate];","        }","    }];","}","","@end"],"type":"codeListing","syntax":"objective-c"},{"level":2,"anchor":"Higher-Order-Functions","text":"Higher-Order Functions","type":"heading"},{"level":3,"anchor":"Swift-Rich-Functional-Programming","text":"Swift: Rich Functional Programming","type":"heading"},{"code":["let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","","\/\/ Map: Transform each element","let squared = numbers.map { $0 * $0 }","print(squared)  \/\/ [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]","","\/\/ Filter: Select elements that match condition","let evens = numbers.filter { $0 % 2 == 0 }","print(evens)  \/\/ [2, 4, 6, 8, 10]","","\/\/ Reduce: Combine elements into single value","let sum = numbers.reduce(0) { $0 + $1 }","let product = numbers.reduce(1, *)  \/\/ Operator function","print(\"Sum: \\(sum), Product: \\(product)\")","","\/\/ CompactMap: Transform and remove nils","let strings = [\"1\", \"2\", \"abc\", \"4\", \"xyz\"]","let validNumbers = strings.compactMap { Int($0) }","print(validNumbers)  \/\/ [1, 2, 4]","","\/\/ Chaining operations","let result = numbers","    .filter { $0 % 2 == 0 }  \/\/ Get even numbers","    .map { $0 * $0 }         \/\/ Square them","    .reduce(0, +)            \/\/ Sum them up","","print(\"Sum of squared evens: \\(result)\")  \/\/ 220","","\/\/ Sort with closure","let words = [\"apple\", \"Banana\", \"cherry\", \"Date\"]","let sortedWords = words.sorted { $0.lowercased() < $1.lowercased() }","print(sortedWords)  \/\/ [\"apple\", \"Banana\", \"cherry\", \"Date\"]"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Objective-C-Limited-Functional-Support","text":"Objective-C: Limited Functional Support","type":"heading"},{"code":["NSArray<NSNumber *> *numbers = @[@1, @2, @3, @4, @5, @6, @7, @8, @9, @10];","","\/\/ Map equivalent (manual implementation)","NSMutableArray<NSNumber *> *squared = [NSMutableArray array];","for (NSNumber *num in numbers) {","    [squared addObject:@([num integerValue] * [num integerValue])];","}","","\/\/ Filter with predicates","NSPredicate *evenPredicate = [NSPredicate predicateWithBlock:^BOOL(NSNumber *number, NSDictionary *bindings) {","    return [number integerValue] % 2 == 0;","}];","NSArray<NSNumber *> *evens = [numbers filteredArrayUsingPredicate:evenPredicate];","","\/\/ Reduce equivalent (manual implementation)","NSInteger sum = 0;","for (NSNumber *num in numbers) {","    sum += [num integerValue];","}","","\/\/ Enumeration with blocks (closest to map)","NSMutableArray<NSNumber *> *doubled = [NSMutableArray array];","[numbers enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) {","    [doubled addObject:@([number integerValue] * 2)];","}];","","\/\/ Sorting with comparator","NSArray<NSString *> *words = @[@\"apple\", @\"Banana\", @\"cherry\", @\"Date\"];","NSArray<NSString *> *sortedWords = [words sortedArrayUsingComparator:^NSComparisonResult(NSString *str1, NSString *str2) {","    return [[str1 lowercaseString] compare:[str2 lowercaseString]];","}];"],"type":"codeListing","syntax":"objective-c"},{"level":2,"anchor":"Async-Closures","text":"Async Closures","type":"heading"},{"level":3,"anchor":"Swift-Modern-AsyncAwait-with-Closures","text":"Swift: Modern Async\/Await with Closures","type":"heading"},{"code":["\/\/ Traditional callback pattern","func fetchData(completion: @escaping @Sendable (Result<String, Error>) -> Void) {","    DispatchQueue.global().async {","        \/\/ Simulate async work","        Thread.sleep(forTimeInterval: 1)","        ","        DispatchQueue.main.async {","            completion(.success(\"Data loaded\"))","        }","    }","}","","\/\/ Modern async\/await","func fetchDataAsync() async -> String {","    \/\/ Simulate async work","    try? await Task.sleep(for: .seconds(1))","    return \"Data loaded\"","}","","\/\/ Usage","Task {","    let data = await fetchDataAsync()","    print(data)","}","","\/\/ Continuation bridge between callback and async","func fetchDataWithContinuation() async -> String {","    return await withCheckedContinuation { continuation in","        fetchData { result in","            switch result {","            case .success(let data):","                continuation.resume(returning: data)","            case .failure(let error):","                continuation.resume(throwing: error)","            }","        }","    }","}"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Objective-C-Traditional-Callback-Pattern","text":"Objective-C: Traditional Callback Pattern","type":"heading"},{"code":["\/\/ Callback with blocks","typedef void(^CompletionBlock)(NSString * _Nullable data, NSError * _Nullable error);","","- (void)fetchDataWithCompletion:(CompletionBlock)completion {","    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{","        \/\/ Simulate async work","        [NSThread sleepForTimeInterval:1.0];","        ","        dispatch_async(dispatch_get_main_queue(), ^{","            completion(@\"Data loaded\", nil);","        });","    });","}","","\/\/ Usage","[self fetchDataWithCompletion:^(NSString *data, NSError *error) {","    if (data) {","        NSLog(@\"%@\", data);","    } else {","        NSLog(@\"Error: %@\", error.localizedDescription);","    }","}];"],"type":"codeListing","syntax":"objective-c"},{"level":2,"anchor":"Performance-Considerations","text":"Performance Considerations","type":"heading"},{"level":3,"anchor":"Swift-Optimized-Closures","text":"Swift: Optimized Closures","type":"heading"},{"code":["\/\/ Closures can be optimized by the compiler","func performanceTest() {","    let numbers = Array(1...1_000_000)","    ","    \/\/ Compiler can optimize this closure","    let sum = numbers.reduce(0, +)","    ","    \/\/ Even complex closures get optimized","    let processedSum = numbers","        .filter { $0 % 2 == 0 }","        .map { $0 * $0 }","        .reduce(0, +)","    ","    print(\"Sum: \\(sum), Processed: \\(processedSum)\")","}","","\/\/ @noescape closures (now automatic) can be further optimized","func synchronousOperation<T, U>(_ value: T, transform: (T) -> U) -> U {","    return transform(value)  \/\/ Closure doesn't escape function","}"],"type":"codeListing","syntax":"swift"},{"level":3,"anchor":"Objective-C-Block-Overhead","text":"Objective-C: Block Overhead","type":"heading"},{"code":["\/\/ Blocks have runtime overhead","- (void)performanceTest {","    NSArray<NSNumber *> *numbers = \/\/ ... large array","    ","    \/\/ Block enumeration has more overhead than direct loops","    __block NSInteger sum = 0;","    [numbers enumerateObjectsUsingBlock:^(NSNumber *number, NSUInteger idx, BOOL *stop) {","        sum += [number integerValue];","    }];","    ","    \/\/ Direct loop is often faster","    NSInteger directSum = 0;","    for (NSNumber *number in numbers) {","        directSum += [number integerValue];","    }","}"],"type":"codeListing","syntax":"objective-c"},{"level":2,"anchor":"Key-Closure-Advantages","text":"Key Closure Advantages","type":"heading"},{"level":3,"anchor":"Swift-Benefits","text":"Swift Benefits","type":"heading"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Cleaner Syntax","type":"text"}]},{"type":"text","text":": Less verbose than Objective-C blocks"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Type Inference"}],"type":"strong"},{"text":": Compiler figures out types automatically","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Trailing Closure","type":"text"}]},{"text":": Reads more naturally for single closure parameters","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Capture Lists"}]},{"type":"text","text":": Explicit memory management control"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Performance"}]},{"type":"text","text":": Better optimization opportunities"}]}]}],"type":"orderedList"},{"type":"heading","level":3,"anchor":"Best-Practices","text":"Best Practices"},{"type":"heading","level":4,"anchor":"Swift-Closure-Guidelines","text":"Swift Closure Guidelines"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"text":"Use trailing closure syntax","type":"text"}],"type":"strong"},{"text":" when closure is the last parameter","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Prefer shorthand argument names"}],"type":"strong"},{"text":" ($0, $1) for simple operations","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Use capture lists"}],"type":"strong"},{"text":" to prevent retain cycles","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Choose appropriate capture semantics"}],"type":"strong"},{"text":" (weak vs unowned)","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Consider async\/await"}]},{"type":"text","text":" over callback-based patterns"}]}]}],"type":"orderedList"},{"syntax":"swift","type":"codeListing","code":["\/\/ Good: Clean, readable closure usage","let results = items","    .filter { $0.isActive }","    .map { $0.name.uppercased() }","    .sorted()","","\/\/ Good: Proper memory management","networkManager.fetch { [weak self] result in","    guard let self = self else { return }","    self.handleResult(result)","}"]},{"type":"paragraph","inlineContent":[{"text":"Swift’s closure system provides the same fundamental capabilities as Objective-C blocks while offering significantly cleaner syntax, better performance, and more powerful features for functional programming patterns.","type":"text"}]}],"kind":"content"}],"schemaVersion":{"patch":0,"minor":3,"major":0},"sections":[],"identifier":{"url":"doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide\/Closures","interfaceLanguage":"swift"},"references":{"doc://com.example.swiftvsobjc/documentation/Swift-vs-Objective-C-Guide":{"identifier":"doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide","type":"topic","kind":"article","role":"collection","title":"Swift vs Objective-C Guide","abstract":[],"url":"\/documentation\/swift-vs-objective-c-guide"}}}