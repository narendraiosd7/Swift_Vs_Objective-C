{"abstract":[{"type":"text","text":"Comparing array, dictionary, and set handling between Swift and Objective-C."}],"metadata":{"roleHeading":"Article","title":"Collections","role":"article"},"sections":[],"hierarchy":{"paths":[["doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide"]]},"kind":"article","primaryContentSections":[{"kind":"content","content":[{"level":2,"anchor":"Overview","text":"Overview","type":"heading"},{"inlineContent":[{"text":"Collections are fundamental to most applications, and Swift provides significant improvements over Objective-C in terms of type safety, syntax clarity, and performance. Swift collections are type-safe, have cleaner syntax, and offer better compile-time guarantees.","type":"text"}],"type":"paragraph"},{"level":2,"anchor":"Arrays","text":"Arrays","type":"heading"},{"level":3,"anchor":"Swift-Arrays-Type-Safe-and-Clean","text":"Swift Arrays: Type-Safe and Clean","type":"heading"},{"syntax":"swift","code":["\/\/ Type-safe arrays","let fruits = [\"Apple\", \"Banana\", \"Cherry\"]        \/\/ [String]","var numbers = [1, 2, 3, 4, 5]                    \/\/ [Int]","var mixedArray: [Any] = [\"Text\", 42, true]       \/\/ Mixed types (rarely used)","","\/\/ Array operations","numbers.append(6)","numbers += [7, 8, 9]","let first = numbers.first  \/\/ Optional(1)","let count = numbers.count  \/\/ 9","","\/\/ Safe subscripting","if numbers.indices.contains(10) {","    let value = numbers[10]","} else {","    print(\"Index out of bounds\")","}","","\/\/ Functional operations","let doubled = numbers.map { $0 * 2 }","let evens = numbers.filter { $0 % 2 == 0 }","let sum = numbers.reduce(0, +)"],"type":"codeListing"},{"level":3,"anchor":"Objective-C-Arrays-Runtime-Type-Checking","text":"Objective-C Arrays: Runtime Type Checking","type":"heading"},{"syntax":"objective-c","code":["\/\/ Mixed type arrays (potential for runtime errors)","NSArray *fruits = @[@\"Apple\", @\"Banana\", @\"Cherry\"];","NSMutableArray *numbers = [@[@1, @2, @3, @4, @5] mutableCopy];","","\/\/ Operations require more verbose syntax","[numbers addObject:@6];","[numbers addObjectsFromArray:@[@7, @8, @9]];","NSNumber *first = [numbers firstObject];  \/\/ Might be nil","NSUInteger count = [numbers count];","","\/\/ Manual bounds checking needed","if (10 < [numbers count]) {","    NSNumber *value = numbers[10];","} else {","    NSLog(@\"Index out of bounds\");","}","","\/\/ No built-in functional operations","NSMutableArray *doubled = [NSMutableArray array];","for (NSNumber *num in numbers) {","    [doubled addObject:@([num integerValue] * 2)];","}"],"type":"codeListing"},{"level":2,"anchor":"Dictionaries","text":"Dictionaries","type":"heading"},{"level":3,"anchor":"Swift-Dictionaries-Type-Safe-Key-Value-Pairs","text":"Swift Dictionaries: Type-Safe Key-Value Pairs","type":"heading"},{"syntax":"swift","code":["\/\/ Type-safe dictionaries","var userInfo = [\"name\": \"Alice\", \"email\": \"alice@example.com\"]  \/\/ [String: String]","var scores = [\"Alice\": 95, \"Bob\": 87, \"Charlie\": 92]            \/\/ [String: Int]","","\/\/ Safe value access (returns optionals)","if let name = userInfo[\"name\"] {","    print(\"User name: \\(name)\")","} else {","    print(\"Name not found\")","}","","\/\/ Updating values","userInfo[\"phone\"] = \"555-1234\"","userInfo.updateValue(\"alice.smith@example.com\", forKey: \"email\")","","\/\/ Iteration","for (key, value) in scores {","    print(\"\\(key): \\(value)\")","}","","\/\/ Functional operations","let highScores = scores.filter { $0.value >= 90 }","let totalScore = scores.values.reduce(0, +)"],"type":"codeListing"},{"level":3,"anchor":"Objective-C-Dictionaries-Runtime-Flexibility","text":"Objective-C Dictionaries: Runtime Flexibility","type":"heading"},{"syntax":"objective-c","code":["\/\/ Mixed type dictionaries","NSMutableDictionary *userInfo = [@{@\"name\": @\"Alice\", ","                                   @\"email\": @\"alice@example.com\"} mutableCopy];","NSDictionary *scores = @{@\"Alice\": @95, @\"Bob\": @87, @\"Charlie\": @92};","","\/\/ Value access (no compile-time guarantee of type)","NSString *name = userInfo[@\"name\"];","if (name) {","    NSLog(@\"User name: %@\", name);","} else {","    NSLog(@\"Name not found\");","}","","\/\/ Updating values","userInfo[@\"phone\"] = @\"555-1234\";","[userInfo setObject:@\"alice.smith@example.com\" forKey:@\"email\"];","","\/\/ Iteration","for (NSString *key in scores) {","    NSNumber *value = scores[key];","    NSLog(@\"%@: %@\", key, value);","}"],"type":"codeListing"},{"level":2,"anchor":"Sets","text":"Sets","type":"heading"},{"level":3,"anchor":"Swift-Sets-Unique-Value-Collections","text":"Swift Sets: Unique Value Collections","type":"heading"},{"syntax":"swift","code":["\/\/ Type-safe sets","var uniqueNumbers: Set<Int> = [1, 2, 3, 4, 5]","var colors: Set = [\"Red\", \"Green\", \"Blue\"]  \/\/ Type inferred as Set<String>","","\/\/ Set operations","uniqueNumbers.insert(6)","uniqueNumbers.remove(3)","let containsFive = uniqueNumbers.contains(5)  \/\/ true","","\/\/ Mathematical set operations","let setA: Set = [1, 2, 3, 4]","let setB: Set = [3, 4, 5, 6]","","let union = setA.union(setB)              \/\/ [1, 2, 3, 4, 5, 6]","let intersection = setA.intersection(setB) \/\/ [3, 4]","let difference = setA.subtracting(setB)    \/\/ [1, 2]"],"type":"codeListing"},{"level":3,"anchor":"Objective-C-Sets-NSSet-and-NSMutableSet","text":"Objective-C Sets: NSSet and NSMutableSet","type":"heading"},{"syntax":"objective-c","code":["\/\/ Object sets","NSMutableSet *uniqueNumbers = [NSMutableSet setWithArray:@[@1, @2, @3, @4, @5]];","NSSet *colors = [NSSet setWithArray:@[@\"Red\", @\"Green\", @\"Blue\"]];","","\/\/ Set operations","[uniqueNumbers addObject:@6];","[uniqueNumbers removeObject:@3];","BOOL containsFive = [uniqueNumbers containsObject:@5];","","\/\/ Mathematical operations (more verbose)","NSSet *setA = [NSSet setWithArray:@[@1, @2, @3, @4]];","NSSet *setB = [NSSet setWithArray:@[@3, @4, @5, @6]];","","NSMutableSet *union = [setA mutableCopy];","[union unionSet:setB];","","NSMutableSet *intersection = [setA mutableCopy];","[intersection intersectSet:setB];"],"type":"codeListing"},{"level":2,"anchor":"Collection-Iteration","text":"Collection Iteration","type":"heading"},{"level":3,"anchor":"Swift-Clean-and-Functional","text":"Swift: Clean and Functional","type":"heading"},{"syntax":"swift","code":["let items = [\"first\", \"second\", \"third\"]","","\/\/ Simple iteration","for item in items {","    print(item)","}","","\/\/ Index and value","for (index, item) in items.enumerated() {","    print(\"\\(index): \\(item)\")","}","","\/\/ Functional iteration","items.forEach { print($0) }","","\/\/ Filtering and mapping","let longItems = items.filter { $0.count > 5 }","let uppercased = items.map { $0.uppercased() }"],"type":"codeListing"},{"level":3,"anchor":"Objective-C-More-Verbose-Options","text":"Objective-C: More Verbose Options","type":"heading"},{"syntax":"objective-c","code":["NSArray *items = @[@\"first\", @\"second\", @\"third\"];","","\/\/ Traditional for loop","for (NSInteger i = 0; i < [items count]; i++) {","    NSString *item = items[i];","    NSLog(@\"%@\", item);","}","","\/\/ Fast enumeration","for (NSString *item in items) {","    NSLog(@\"%@\", item);","}","","\/\/ Block-based enumeration","[items enumerateObjectsUsingBlock:^(NSString *item, NSUInteger idx, BOOL *stop) {","    NSLog(@\"%lu: %@\", (unsigned long)idx, item);","}];"],"type":"codeListing"},{"level":2,"anchor":"Performance-Characteristics","text":"Performance Characteristics","type":"heading"},{"level":3,"anchor":"Swift-Advantages","text":"Swift Advantages","type":"heading"},{"items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Value Types","type":"text"}]},{"type":"text","text":": Arrays and dictionaries are structs, enabling copy-on-write optimization"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Type Specialization"}],"type":"strong"},{"text":": Compiler generates optimized code for specific types","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Bridging","type":"text"}]},{"type":"text","text":": Efficient bridging to Foundation when needed"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Functional Operations"}]},{"text":": Built-in map, filter, reduce are optimized","type":"text"}]}]}],"type":"unorderedList"},{"text":"Memory Management","level":3,"type":"heading","anchor":"Memory-Management"},{"type":"codeListing","syntax":"swift","code":["\/\/ Swift: Automatic copy-on-write","var original = [1, 2, 3, 4, 5]","var copy = original        \/\/ Shares storage","copy.append(6)            \/\/ Now makes actual copy","","\/\/ Objective-C: Manual copying decisions","NSArray *original = @[@1, @2, @3, @4, @5];","NSMutableArray *copy = [original mutableCopy];  \/\/ Always copies"]},{"text":"Type Safety Benefits","level":2,"type":"heading","anchor":"Type-Safety-Benefits"},{"text":"Swift: Compile-Time Guarantees","level":3,"type":"heading","anchor":"Swift-Compile-Time-Guarantees"},{"type":"codeListing","syntax":"swift","code":["let strings = [\"A\", \"B\", \"C\"]","let numbers = [1, 2, 3]","","\/\/ This won't compile - type mismatch caught early","\/\/ let mixed = strings + numbers  \/\/ Error!","","\/\/ Safe type conversion","let stringNumbers = numbers.map { String($0) }","let combined = strings + stringNumbers  \/\/ [\"A\", \"B\", \"C\", \"1\", \"2\", \"3\"]"]},{"text":"Objective-C: Runtime Discovery","level":3,"type":"heading","anchor":"Objective-C-Runtime-Discovery"},{"type":"codeListing","syntax":"objective-c","code":["NSArray *strings = @[@\"A\", @\"B\", @\"C\"];","NSArray *numbers = @[@1, @2, @3];","","\/\/ This compiles but might cause runtime issues","NSMutableArray *mixed = [NSMutableArray array];","[mixed addObjectsFromArray:strings];","[mixed addObjectsFromArray:numbers];","","\/\/ Type checking happens at runtime","for (id object in mixed) {","    if ([object isKindOfClass:[NSString class]]) {","        NSString *string = (NSString *)object;","        \/\/ Handle string","    } else if ([object isKindOfClass:[NSNumber class]]) {","        NSNumber *number = (NSNumber *)object;","        \/\/ Handle number","    }","}"]},{"text":"Migration Tips","level":2,"type":"heading","anchor":"Migration-Tips"},{"type":"paragraph","inlineContent":[{"text":"When converting from Objective-C to Swift collections:","type":"text"}]},{"type":"orderedList","items":[{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Add Type Information"}]},{"type":"text","text":": Specify element types explicitly when needed"}],"type":"paragraph"}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Use Optional Binding"}]},{"text":": Handle nil values from dictionary lookups safely","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Embrace Immutability"}]},{"text":": Use ","type":"text"},{"code":"let","type":"codeVoice"},{"text":" for collections that don’t change","type":"text"}]}]},{"content":[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Leverage Functional Operations"}],"type":"strong"},{"text":": Replace loops with map, filter, reduce","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Consider Value Semantics"}]},{"text":": Understand copying behavior differences","type":"text"}]}]}]},{"anchor":"Best-Practices","level":2,"type":"heading","text":"Best Practices"},{"anchor":"Swift-Collection-Best-Practices","level":3,"type":"heading","text":"Swift Collection Best Practices"},{"items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Default to Immutable"}]},{"type":"text","text":": Use "},{"type":"codeVoice","code":"let"},{"type":"text","text":" unless mutation is required"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Be Explicit About Types"}]},{"type":"text","text":": When working with mixed data"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Use Appropriate Collection","type":"text"}]},{"type":"text","text":": Array for order, Set for uniqueness, Dictionary for lookup"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Functional Style"}],"type":"strong"},{"type":"text","text":": Prefer map\/filter\/reduce over manual loops"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Safe Access"}]},{"type":"text","text":": Always handle optional returns from dictionary lookups"}],"type":"paragraph"}]}],"type":"orderedList"},{"inlineContent":[{"type":"text","text":"Swift’s collection types provide the same functionality as Objective-C with significant improvements in safety, performance, and expressiveness. The type system prevents many runtime errors while the functional programming features enable more concise and readable code."}],"type":"paragraph"}]}],"schemaVersion":{"minor":3,"major":0,"patch":0},"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide\/Collections"},"references":{"doc://com.example.swiftvsobjc/documentation/Swift-vs-Objective-C-Guide":{"identifier":"doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide","type":"topic","kind":"article","role":"collection","title":"Swift vs Objective-C Guide","abstract":[],"url":"\/documentation\/swift-vs-objective-c-guide"}}}