{"identifier":{"interfaceLanguage":"swift","url":"doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide\/MemoryManagement"},"sections":[],"metadata":{"title":"Memory Management","roleHeading":"Article","role":"article"},"schemaVersion":{"minor":3,"major":0,"patch":0},"abstract":[{"text":"Understanding automatic reference counting and memory management differences between Swift and Objective-C.","type":"text"}],"hierarchy":{"paths":[["doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide"]]},"primaryContentSections":[{"kind":"content","content":[{"type":"heading","text":"Overview","anchor":"Overview","level":2},{"type":"paragraph","inlineContent":[{"type":"text","text":"Both Swift and Objective-C use Automatic Reference Counting (ARC) for memory management, but Swift provides better safety features and clearer syntax for handling memory-related issues like retain cycles."}]},{"type":"heading","text":"Basic Memory Management","anchor":"Basic-Memory-Management","level":2},{"type":"heading","text":"Swift: Clean ARC with Clear Syntax","anchor":"Swift-Clean-ARC-with-Clear-Syntax","level":3},{"type":"codeListing","syntax":"swift","code":["class Person {","    let name: String","    var pet: Pet?","    ","    init(name: String) {","        self.name = name","        print(\"\\(name) is created\")","    }","    ","    deinit {","        print(\"\\(name) is being deallocated\")","    }","}","","class Pet {","    let name: String","    weak var owner: Person?  \/\/ Weak reference prevents retain cycle","    ","    init(name: String) {","        self.name = name","        print(\"Pet \\(name) is created\")","    }","    ","    deinit {","        print(\"Pet \\(name) is being deallocated\")","    }","}","","\/\/ Usage - automatic cleanup","do {","    let john = Person(name: \"John\")","    let fluffy = Pet(name: \"Fluffy\")","    ","    john.pet = fluffy","    fluffy.owner = john  \/\/ Weak reference - no retain cycle","    ","    print(\"Relationships established\")","} \/\/ Both objects deallocated here"]},{"type":"heading","text":"Objective-C: ARC with Manual Annotations","anchor":"Objective-C-ARC-with-Manual-Annotations","level":3},{"type":"codeListing","syntax":"objective-c","code":["@interface Person : NSObject","@property (nonatomic, strong, readonly) NSString *name;","@property (nonatomic, strong) Pet *pet;","- (instancetype)initWithName:(NSString *)name;","@end","","@interface Pet : NSObject","@property (nonatomic, strong, readonly) NSString *name;","@property (nonatomic, weak) Person *owner;  \/\/ Weak to prevent cycle","- (instancetype)initWithName:(NSString *)name;","@end","","@implementation Person","- (instancetype)initWithName:(NSString *)name {","    self = [super init];","    if (self) {","        _name = name;","        NSLog(@\"%@ is created\", name);","    }","    return self;","}","","- (void)dealloc {","    NSLog(@\"%@ is being deallocated\", self.name);","}","@end","","@implementation Pet","- (instancetype)initWithName:(NSString *)name {","    self = [super init];","    if (self) {","        _name = name;","        NSLog(@\"Pet %@ is created\", name);","    }","    return self;","}","","- (void)dealloc {","    NSLog(@\"Pet %@ is being deallocated\", self.name);","}","@end"]},{"type":"heading","text":"Reference Types","anchor":"Reference-Types","level":2},{"type":"heading","text":"Swift: weak, unowned, and strong","anchor":"Swift-weak-unowned-and-strong","level":3},{"type":"codeListing","syntax":"swift","code":["class Course {","    let name: String","    var instructor: Instructor?","    weak var department: Department?  \/\/ Weak - department outlives course","    ","    init(name: String) {","        self.name = name","    }","    ","    deinit {","        print(\"Course \\(name) deallocated\")","    }","}","","class Instructor {","    let name: String","    unowned let university: University  \/\/ Unowned - university always outlives instructor","    var courses: [Course] = []","    ","    init(name: String, university: University) {","        self.name = name","        self.university = university","    }","    ","    deinit {","        print(\"Instructor \\(name) deallocated\")","    }","}","","class University {","    let name: String","    ","    init(name: String) {","        self.name = name","    }","    ","    deinit {","        print(\"University \\(name) deallocated\")","    }","}","","class Department {","    let name: String","    var courses: [Course] = []","    ","    init(name: String) {","        self.name = name","    }","    ","    deinit {","        print(\"Department \\(name) deallocated\")","    }","}"]},{"type":"heading","text":"Objective-C: strong, weak, unsafe_unretained","anchor":"Objective-C-strong-weak-unsafeunretained","level":3},{"type":"codeListing","syntax":"objective-c","code":["@interface Course : NSObject","@property (nonatomic, strong, readonly) NSString *name;","@property (nonatomic, strong) Instructor *instructor;","@property (nonatomic, weak) Department *department;","@end","","@interface Instructor : NSObject","@property (nonatomic, strong, readonly) NSString *name;","@property (nonatomic, unsafe_unretained, readonly) University *university;","@property (nonatomic, strong) NSMutableArray<Course *> *courses;","@end","","@interface University : NSObject","@property (nonatomic, strong, readonly) NSString *name;","@end","","@interface Department : NSObject","@property (nonatomic, strong, readonly) NSString *name;","@property (nonatomic, strong) NSMutableArray<Course *> *courses;","@end"]},{"type":"heading","text":"Closure\/Block Retain Cycles","anchor":"ClosureBlock-Retain-Cycles","level":2},{"type":"heading","text":"Swift: Capture Lists for Safety","anchor":"Swift-Capture-Lists-for-Safety","level":3},{"type":"codeListing","syntax":"swift","code":["class NetworkManager {","    var completion: ((String) -> Void)?","    ","    func fetchData() {","        \/\/ Problem: Strong reference cycle","        self.completion = { data in","            self.processData(data)  \/\/ Captures self strongly","        }","        ","        \/\/ Solution: Weak capture","        self.completion = { [weak self] data in","            self?.processData(data)  \/\/ Safe - weak reference","        }","        ","        \/\/ Alternative: Unowned capture (when self is guaranteed to exist)","        self.completion = { [unowned self] data in","            self.processData(data)  \/\/ Crashes if self is deallocated","        }","    }","    ","    private func processData(_ data: String) {","        print(\"Processing: \\(data)\")","    }","    ","    deinit {","        print(\"NetworkManager deallocated\")","    }","}","","\/\/ Usage","var manager: NetworkManager? = NetworkManager()","manager?.fetchData()","manager = nil  \/\/ Will deallocate if no retain cycles"]},{"type":"heading","text":"Objective-C: __weak and __block","anchor":"Objective-C-weak-and-block","level":3},{"type":"codeListing","syntax":"objective-c","code":["@interface NetworkManager : NSObject","@property (nonatomic, copy) void (^completion)(NSString *data);","- (void)fetchData;","@end","","@implementation NetworkManager","","- (void)fetchData {","    \/\/ Problem: Strong reference cycle","    self.completion = ^(NSString *data) {","        [self processData:data];  \/\/ Captures self strongly","    };","    ","    \/\/ Solution: Weak reference","    __weak typeof(self) weakSelf = self;","    self.completion = ^(NSString *data) {","        __strong typeof(weakSelf) strongSelf = weakSelf;","        if (strongSelf) {","            [strongSelf processData:data];","        }","    };","}","","- (void)processData:(NSString *)data {","    NSLog(@\"Processing: %@\", data);","}","","- (void)dealloc {","    NSLog(@\"NetworkManager deallocated\");","}","","@end"]},{"type":"heading","text":"Value vs Reference Types","anchor":"Value-vs-Reference-Types","level":2},{"type":"heading","text":"Swift: Struct Value Semantics","anchor":"Swift-Struct-Value-Semantics","level":3},{"type":"codeListing","syntax":"swift","code":["struct Point {","    var x: Double","    var y: Double","}","","class PointManager {","    var points: [Point] = []","    ","    func addPoint(_ point: Point) {","        points.append(point)  \/\/ Point is copied, no memory management needed","    }","}","","\/\/ Value types don't participate in ARC","var point1 = Point(x: 1.0, y: 2.0)","var point2 = point1  \/\/ Copied, not shared","point2.x = 5.0      \/\/ point1 unchanged","","let manager = PointManager()","manager.addPoint(point1)  \/\/ point1 is copied into array"]},{"type":"heading","text":"Objective-C: All Objects are Reference Types","anchor":"Objective-C-All-Objects-are-Reference-Types","level":3},{"type":"codeListing","syntax":"objective-c","code":["\/\/ In Objective-C, all objects are reference types","\/\/ Structs exist but are basic C structs without ARC","typedef struct {","    double x;","    double y;","} Point;  \/\/ Basic struct, no memory management","","@interface PointManager : NSObject","@property (nonatomic, strong) NSMutableArray<NSValue *> *points;","- (void)addPoint:(Point)point;","@end","","@implementation PointManager","- (void)addPoint:(Point)point {","    NSValue *pointValue = [NSValue valueWithBytes:&point objCType:@encode(Point)];","    [self.points addObject:pointValue];  \/\/ Must box into NSValue","}","@end"]},{"type":"heading","text":"Memory Management Best Practices","anchor":"Memory-Management-Best-Practices","level":2},{"type":"heading","text":"Swift Guidelines","anchor":"Swift-Guidelines","level":3},{"type":"orderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"text":"Use weak references","type":"text"}]},{"text":" for delegate patterns","type":"text"}]}]},{"content":[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Use unowned","type":"text"}]},{"text":" when you guarantee the referenced object outlives the referencing one","type":"text"}],"type":"paragraph"}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Capture lists in closures"}]},{"type":"text","text":" to prevent retain cycles"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"inlineContent":[{"type":"text","text":"Prefer value types"}],"type":"strong"},{"text":" when you don’t need reference semantics","type":"text"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Use defer"}]},{"type":"text","text":" for cleanup code"}]}]}]},{"type":"codeListing","syntax":"swift","code":["class APIClient {","    weak var delegate: APIClientDelegate?  \/\/ Delegate pattern","    ","    func performRequest() {","        defer {","            \/\/ Cleanup code always runs","            print(\"Request completed\")","        }","        ","        let task = URLSession.shared.dataTask(with: url) { [weak self] data, response, error in","            guard let self = self else { return }  \/\/ Safe unwrap","            ","            if let error = error {","                self.delegate?.client(self, didFailWith: error)","            } else if let data = data {","                self.delegate?.client(self, didReceive: data)","            }","        }","        ","        task.resume()","    }","}","","protocol APIClientDelegate: AnyObject {","    func client(_ client: APIClient, didReceive data: Data)","    func client(_ client: APIClient, didFailWith error: Error)","}"]},{"type":"heading","text":"Common Memory Pitfalls","anchor":"Common-Memory-Pitfalls","level":3},{"type":"heading","text":"Swift: Avoiding Retain Cycles","anchor":"Swift-Avoiding-Retain-Cycles","level":4},{"type":"codeListing","syntax":"swift","code":["\/\/ Problem: Timer retain cycle","class TimerViewController {","    var timer: Timer?","    ","    func startTimer() {","        \/\/ Problematic - timer retains target (self)","        timer = Timer.scheduledTimer(timeInterval: 1.0, ","                                   target: self, ","                                   selector: #selector(tick), ","                                   userInfo: nil, ","                                   repeats: true)","    }","    ","    \/\/ Solution: Use weak references or proper cleanup","    func startTimerSafely() {","        timer = Timer.scheduledTimer(withTimeInterval: 1.0, repeats: true) { [weak self] _ in","            self?.tick()","        }","    }","    ","    @objc func tick() {","        print(\"Tick\")","    }","    ","    deinit {","        timer?.invalidate()  \/\/ Always invalidate in deinit","    }","}"]},{"type":"heading","text":"Memory Management Summary","anchor":"Memory-Management-Summary","level":2},{"type":"table","header":"row","rows":[[[{"inlineContent":[{"text":"Feature","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Swift","type":"text"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Objective-C"}],"type":"paragraph"}]],[[{"inlineContent":[{"inlineContent":[{"text":"ARC","type":"text"}],"type":"strong"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Automatic, always on"}],"type":"paragraph"}],[{"inlineContent":[{"text":"Automatic in modern code","type":"text"}],"type":"paragraph"}]],[[{"inlineContent":[{"inlineContent":[{"text":"Weak References","type":"text"}],"type":"strong"}],"type":"paragraph"}],[{"inlineContent":[{"code":"weak var","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"__weak"},{"text":" or ","type":"text"},{"type":"codeVoice","code":"@property weak"}],"type":"paragraph"}]],[[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Unowned References"}],"type":"strong"}],"type":"paragraph"}],[{"inlineContent":[{"code":"unowned","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"type":"codeVoice","code":"unsafe_unretained"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"strong","inlineContent":[{"text":"Closure Capture","type":"text"}]}],"type":"paragraph"}],[{"inlineContent":[{"code":"[weak self]","type":"codeVoice"},{"text":", ","type":"text"},{"code":"[unowned self]","type":"codeVoice"}],"type":"paragraph"}],[{"inlineContent":[{"code":"__weak","type":"codeVoice"},{"type":"text","text":", "},{"code":"__strong","type":"codeVoice"},{"type":"text","text":" dance"}],"type":"paragraph"}]],[[{"inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Value Types"}]}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Structs don’t use ARC"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Limited to C structs"}],"type":"paragraph"}]],[[{"inlineContent":[{"inlineContent":[{"type":"text","text":"Syntax"}],"type":"strong"}],"type":"paragraph"}],[{"inlineContent":[{"type":"text","text":"Cleaner, more explicit"}],"type":"paragraph"}],[{"inlineContent":[{"text":"More verbose annotations","type":"text"}],"type":"paragraph"}]]]},{"type":"paragraph","inlineContent":[{"text":"Swift’s memory management provides the same power as Objective-C’s ARC system while offering cleaner syntax and better safety features for preventing common memory management errors.","type":"text"}]}]}],"kind":"article","references":{"doc://com.example.swiftvsobjc/documentation/Swift-vs-Objective-C-Guide":{"identifier":"doc:\/\/com.example.swiftvsobjc\/documentation\/Swift-vs-Objective-C-Guide","type":"topic","kind":"article","role":"collection","title":"Swift vs Objective-C Guide","abstract":[],"url":"\/documentation\/swift-vs-objective-c-guide"}}}